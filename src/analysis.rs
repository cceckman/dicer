//! Well-formedness checking (semantic analysis) of dice expressions.
//!
//! We need to make sure:
//! - All symbols are defined when used.
//! - Symbols do not conflict.
//! - Keep-highest / keep-lowest are always valid
//! - Division never divides by zero
//!

use crate::{
    Error,
    parse::RawExpression,
    symbolic::{Constant, Die, ExpressionTree, ExpressionWrapper, Symbol},
};

/// An dice expression that is well-formed per semantic analysis.
///
/// - All symbols are declared before use, in the context of their use.
/// -
#[derive(Debug)]
pub struct WellFormed(ExpressionTree<WellFormed>);

impl TryFrom<RawExpression> for WellFormed {
    type Error = Error;

    fn try_from(value: RawExpression) -> Result<Self, Self::Error> {
        WellFormed::check(&value, &AvailableBinding::Root)
    }
}

impl From<ExpressionTree<WellFormed>> for WellFormed {
    fn from(value: ExpressionTree<WellFormed>) -> Self {
        WellFormed(value)
    }
}

impl ExpressionWrapper for WellFormed {
    fn inner(&self) -> &ExpressionTree<Self> {
        &self.0
    }
}

impl std::fmt::Display for WellFormed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.0.fmt(f)
    }
}

/// Linked list (on the stack) of current symbol bindings.
#[derive(Copy, Clone)]
enum AvailableBinding<'a> {
    Root,
    Chain {
        defined: &'a Symbol,
        definition: &'a WellFormed,
        prev: &'a AvailableBinding<'a>,
    },
}

impl AvailableBinding<'_> {
    /// Search the stack of bindings for the provided symbol.
    fn search(&self, needle: &Symbol) -> Option<&WellFormed> {
        let mut current: &AvailableBinding = self;
        while let AvailableBinding::Chain {
            defined,
            prev,
            definition,
        } = current
        {
            if *defined == needle {
                return Some(definition);
            } else {
                current = prev;
            }
        }
        None
    }
}

impl WellFormed {
    fn maximum(&self, symbols: &AvailableBinding) -> isize {
        match self.inner() {
            ExpressionTree::Modifier(Constant(m)) => *m as isize,
            ExpressionTree::Die(Die(d)) => *d as isize,
            ExpressionTree::Symbol(symbol) => {
                let v = symbols
                    .search(symbol)
                    .expect("well-formed expression may only resolve defined symbols");
                v.maximum(symbols)
            }
            ExpressionTree::Negated(x) => -x.minimum(symbols),
            ExpressionTree::Repeated {
                count,
                value,
                ranker,
            } => {
                let max_count = count.maximum(symbols);
                let max_value = value.maximum(symbols);
                let count = std::cmp::min(ranker.count() as isize, max_count);
                count * max_value
            }
            ExpressionTree::Product(a, b) => {
                // TODO: Fix this- doesn't handle sign correctly.
                a.maximum(symbols) * b.maximum(symbols)
            }
            ExpressionTree::Sum(items) => items.iter().map(|v| v.maximum(symbols)).sum(),
            ExpressionTree::Floor(a, b) => {
                // TODO: Fix this- doesn't handle sign correctly.
                a.maximum(symbols) / b.minimum(symbols)
            }
            ExpressionTree::Comparison { .. } => {
                // TODO: : could short-circuit on refutable comparison.
                // For now, we assume every condition could be true or false.
                1
            }
            ExpressionTree::Binding {
                symbol,
                value,
                tail,
            } => {
                // We don't know if "min" or "max" gives us the max of the underlying expression.
                // Try both.
                // (All the operators we have are linear.... I think?)
                [value.maximum(symbols), value.minimum(symbols)]
                    .map(|v| {
                        let constant =
                            WellFormed(ExpressionTree::Modifier(Constant(v.unsigned_abs())));
                        let definition = if v >= 0 {
                            constant
                        } else {
                            WellFormed(ExpressionTree::Negated(Box::new(constant)))
                        };

                        let binding = AvailableBinding::Chain {
                            defined: symbol,
                            definition: &definition,
                            prev: symbols,
                        };

                        tail.maximum(&binding)
                    })
                    .iter()
                    .fold(isize::MIN, |a, b| std::cmp::max(a, *b))
            }
        }
    }

    /// Return the minimum possible value that can be generated by this expression.
    fn minimum(&self, symbols: &AvailableBinding) -> isize {
        match self.inner() {
            ExpressionTree::Modifier(Constant(m)) => *m as isize,
            ExpressionTree::Die(Die(d)) => *d as isize,
            ExpressionTree::Symbol(symbol) => {
                let v = symbols
                    .search(symbol)
                    .expect("well-formed expression may only resolve defined symbols");
                v.minimum(symbols)
            }
            ExpressionTree::Negated(x) => -x.maximum(symbols),
            ExpressionTree::Repeated {
                count,
                value,
                ranker,
            } => {
                let max_count = count.minimum(symbols);
                let max_value = value.minimum(symbols);
                let count = std::cmp::min(ranker.count() as isize, max_count);
                count * max_value
            }
            ExpressionTree::Product(a, b) => {
                // TODO: Fix this- doesn't handle sign correctly
                a.minimum(symbols) * b.minimum(symbols)
            }
            ExpressionTree::Sum(items) => {
                // This handles sign correctly.
                items.iter().map(|v| v.minimum(symbols)).sum()
            }
            ExpressionTree::Floor(a, b) => {
                // TODO: Fix this- doesn't handle sign correctly.
                a.minimum(symbols) / b.maximum(symbols)
            }
            ExpressionTree::Comparison { .. } => {
                // TODO: : could short-circuit on refutable comparison.
                // For now, we assume every condition could be true or false.
                0
            }
            ExpressionTree::Binding {
                symbol,
                value,
                tail,
            } => {
                // We don't know if "min" or "max" gives us the max of the underlying expression.
                // Try both.
                // (All the operators we have are linear.... I think?)
                [value.maximum(symbols), value.minimum(symbols)]
                    .map(|v| {
                        let constant =
                            WellFormed(ExpressionTree::Modifier(Constant(v.unsigned_abs())));
                        let definition = if v >= 0 {
                            constant
                        } else {
                            WellFormed(ExpressionTree::Negated(Box::new(constant)))
                        };

                        let binding = AvailableBinding::Chain {
                            defined: symbol,
                            definition: &definition,
                            prev: symbols,
                        };

                        tail.minimum(&binding)
                    })
                    .iter()
                    .fold(isize::MAX, |a, b| std::cmp::min(a, *b))
            }
        }
    }
}

impl WellFormed {
    /// Recursively check that this expression is well-formed, given the provided stack of
    /// bindings.
    fn check(target: &RawExpression, symbols: &AvailableBinding) -> Result<WellFormed, Error> {
        let tree: Result<ExpressionTree<WellFormed>, _> = match target.inner() {
            ExpressionTree::Modifier(m) => Ok(ExpressionTree::Modifier(*m)),
            ExpressionTree::Die(d) => Ok(ExpressionTree::Die(*d)),
            ExpressionTree::Symbol(symbol) => {
                if symbols.search(symbol).is_some() {
                    Ok(ExpressionTree::Symbol(symbol.to_owned()))
                } else {
                    Err(Error::SymbolUndefined(symbol.to_owned()))
                }
            }
            ExpressionTree::Negated(n) => {
                let n = WellFormed::check(n, symbols)?;
                Ok(ExpressionTree::Negated(Box::new(n)))
            }
            ExpressionTree::Repeated {
                count,
                value,
                ranker,
            } => {
                let count = Box::new(WellFormed::check(count, symbols)?);
                let value = Box::new(WellFormed::check(value, symbols)?);

                let min_count = count.minimum(symbols);
                if min_count < (ranker.count() as isize) {
                    Err(crate::Error::KeepTooFew(ranker.count(), count.to_string()))
                } else {
                    Ok(ExpressionTree::Repeated {
                        count,
                        value,
                        ranker: *ranker,
                    })
                }
            }
            ExpressionTree::Product(a, b) => {
                let a = Box::new(WellFormed::check(a, symbols)?);
                let b = Box::new(WellFormed::check(b, symbols)?);
                Ok(ExpressionTree::Product(a, b))
            }
            ExpressionTree::Sum(expression_trees) => {
                let r: Result<_, _> = expression_trees
                    .iter()
                    .map(|e| WellFormed::check(e, symbols))
                    .collect();
                let es = r?;
                Ok(ExpressionTree::Sum(es))
            }
            ExpressionTree::Floor(a, b) => {
                let a = Box::new(WellFormed::check(a, symbols)?);
                let b = Box::new(WellFormed::check(b, symbols)?);
                Ok(ExpressionTree::Floor(a, b))
            }
            ExpressionTree::Comparison { a, b, op } => {
                let a = Box::new(WellFormed::check(a, symbols)?);
                let b = Box::new(WellFormed::check(b, symbols)?);
                Ok(ExpressionTree::Comparison { a, b, op: *op })
            }

            ExpressionTree::Binding {
                symbol,
                value,
                tail,
            } => {
                if symbols.search(symbol).is_some() {
                    return Err(Error::SymbolRedefined(symbol.to_owned()));
                }
                let value = WellFormed::check(value, symbols)?;
                let next_avail = AvailableBinding::Chain {
                    defined: symbol,
                    definition: &value,
                    prev: symbols,
                };
                let tail = WellFormed::check(tail, &next_avail)?;
                Ok(ExpressionTree::Binding {
                    symbol: symbol.clone(),
                    value: Box::new(value),
                    tail: Box::new(tail),
                })
            }
        };
        tree.map(WellFormed)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn undefined_reference() {
        let v: RawExpression = "[ABC: 1d20] BCD".parse().unwrap();
        let e = std::convert::TryInto::<WellFormed>::try_into(v).unwrap_err();
        let e_target: Symbol = "BCD".parse().unwrap();
        match e {
            crate::Error::SymbolUndefined(sym) if sym == e_target => (),
            x => panic!("unexpected error: {x}"),
        }
    }

    #[test]
    fn redefined_reference() {
        let v: RawExpression = "[ABC: 1d20] [ABC:2d10] ABC + ABC".parse().unwrap();
        let e = std::convert::TryInto::<WellFormed>::try_into(v).unwrap_err();
        let e_target = "ABC".parse().unwrap();
        assert!(matches!(e, crate::Error::SymbolRedefined(sym) if sym == e_target));
    }

    #[test]
    fn undefined_contextural() {
        let v: RawExpression = "2([ATK: 1d20] (ATK + 1 > 10) * 10) + ATK".parse().unwrap();
        let e = std::convert::TryInto::<WellFormed>::try_into(v).unwrap_err();
        let e_target = "ATK".parse().unwrap();
        assert!(matches!(e, crate::Error::SymbolUndefined(sym) if sym == e_target));
    }

    #[test]
    fn keep_enough_high() {
        let v: RawExpression = "3d20kh4".parse().unwrap();
        let e = std::convert::TryInto::<WellFormed>::try_into(v).unwrap_err();
        assert!(matches!(e, crate::Error::KeepTooFew(_, _)));
    }

    #[test]
    fn keep_enough_low() {
        let v: RawExpression = "3d20kl4".parse().unwrap();
        let e = std::convert::TryInto::<WellFormed>::try_into(v).unwrap_err();
        assert!(matches!(e, crate::Error::KeepTooFew(_, _)));
    }
}
